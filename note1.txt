// docker container command
docker container run --publish 3000:80 --name webserver --detach nginx
docker container ls              ...  same as docker ps
docker container ls -a           ...  same as docker ps -a
docker container logs webserver  ...  view logs of container. `-f` to follow logs, `-n` to view number of lines frm logs
docker container top webserver   ...  view running process of the container
docker container port webserver  ...  to view list of port mappings

docker container top [container-name-or-id]     ... view process list in the container
docker container inspect [container-name-or-id] ... view details of the container
docker container stats                          ... view performance stats of ALL containers

docker container exec -it mysql bash                                ... run bash on mysql container
docker container ls                                                 ... when you exit frm mysql bash, only bash process is terminated, mysql container is still active            
docker container inspect -f '{{.NetworkSettings.IPAddress}}' nginx1 ... to view IPAddress of container nginx1 (using `-f or --format` flag to filter)


// docker network command
docker network ls
docker network inspect [network-name]                  ... inspect the docker network 
docker network connect [OPTIONS] NETWORK CONTAINER     ... attach a network to container
docker network disconnect [OPTIONS] NETWORK CONTAINER  ... detach a network from container


// docker networks: DNS
// example1) create 2 nginx containers & execute ping command frm nginx1 to nginx2 using custom network (bridge driver, with built-in DNS server)
// when we create new network "nginxnet" (bridge), it will automatically has DNS server built into it unlike default "bridge" network.
// default "bridge" network does not have DNS server built in it, which is why without manually connect the containers to our custom network "nginxnet",
// we could not let containers to communicate with each other (using default "bridge" network, we CANNOT execute `docker container exec nginx1 ping nginx2`. 
// Therefore, we use "nginxnet" which uses "bridge" driver)
docker container run -d --name nginx1 nginx
docker container run -d --name nginx2 nginx
docker network create --driver bridge nginxnet  ... create new network named "nginxnet" using bridge driver (default is bridge)
docker network connect nginxnet nginx1          ... container name "nginx1" is also the container DNS now   
docker network connect nginxnet nginx2          ... container name "nginx2" is also the container DNS now

docker container exec nginx1 ping nginx2 
docker container exec nginx2 ping nginx1
// OR 
docker container exec -it nginx1 ping nginx2    ... since now nginx1 & nginx2 is in same network, they can communicate with each other!
docker container exec -it nginx2 ping nginx1        ** using default bridge network (no DNS server built-in), this WONT work!
                                                    ** the work around of this is by using `--link` flag to link nginx1 & nginx2 (see example2 below)


// example2) create 2 nginx containers & execute ping command frm nginx1 to nginx2 using default bridge network (NO built-in DNS server)
// since default bridge network does NOT have DNS server built-in, we need to use `--link` flag to establish connection between containers
docker container run -d --name nginx3 --link nginx4:nginx4 nginx
docker container run -d --name nginx4 --link nginx3:nginx3 nginx

docker container exec nginx3 ping nginx4
docker container exec nginx4 ping nginx3
// OR
docker container exec -it nginx3 ping nginx4
docker container exec -it nginx4 ping nginx3


// example3) DNS Round Robin
// in docker container run command, using flag `--network-alias` it means: 
// I want another DNS alias to call this container by (besides its container name which is also its DNS)
// Since we use `--network-alias`, we do NOT need to name the containers, we are just gonna use the network-alias.
// Every request comes to the defined network-alias will be forwarded to either one of the containers (they all have same network-alias, sanme DNS so to say)
// which makes DNS round robin possible.
// in this example, we use `nslookup`. nslookup (name server lookup) is a tool used to perform DNS lookups in Linux
docker network create searchnet
docker container run -d --network searchnet --network-alias search elasticsearch:2
docker container run -d --network searchnet --network-alias search elasticsearch:2  ... we run 2 containers with similar DNS "search"

docker container ls     ... we can see that they have different container name (since we never specify the name), they have same DNS name "search"
```
CONTAINER ID   IMAGE             COMMAND                  CREATED             STATUS             PORTS                  NAMES
fb3647249f5f   elasticsearch:2   "/docker-entrypoint.…"   36 seconds ago      Up 34 seconds      9200/tcp, 9300/tcp     happy_mirzakhani
bb4faac84bd8   elasticsearch:2   "/docker-entrypoint.…"   41 seconds ago      Up 39 seconds      9200/tcp, 9300/tcp     dreamy_gauss
```

// testing it by lookup to "search" DNS entry to see which IPs are registered to the DNS
// testing it from alpine which HAS TO BE FROM SAME NETWORK ("searchnet")
// the test will give 2 of our container IPs assigned to DNS "search"
// we can check both our container IPs (`docker container inspect [container-IDs...] -f '{{.NetworkSettings.Networks.searchnet.IPAddress}}'`)
docker container run --rm --network searchnet alpine nslookup search    ... test using linux alpine

```
Name:	search
Address: 172.20.0.3
Name:	search
Address: 172.20.0.2
```


// test using centos `curl`. Run it multiple times to get response frm different container
// this show DNS round robin
docker container run --rm --network searchnet centos curl -s search:9200    ... both containers run on port 9200 (curl -s... `-s` for silent mode)
```
{
  "name" : "Apollo",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "eIBJKchgTzelPcqR5jwLbg",
  "version" : {
    "number" : "2.4.6",
    "build_hash" : "5376dca9f70f3abef96a77f4bb22720ace8240fd",
    "build_timestamp" : "2017-07-18T12:17:44Z",
    "build_snapshot" : false,
    "lucene_version" : "5.5.4"
  },
  "tagline" : "You Know, for Search"
}
```

docker container run --rm --network searchnet centos curl -s search:9200    ... both containers run on port 9200 (curl -s... `-s` for silent mode)
```
{
  "name" : "Poison",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "h1y4ZXCUSoeHFhZsD2FTbw",
  "version" : {
    "number" : "2.4.6",
    "build_hash" : "5376dca9f70f3abef96a77f4bb22720ace8240fd",
    "build_timestamp" : "2017-07-18T12:17:44Z",
    "build_snapshot" : false,
    "lucene_version" : "5.5.4"
  },
  "tagline" : "You Know, for Search"
}
```


// testing using ubuntu curl
docker container run -it --network searchnet ubuntu
> apt-get update & apt-get install -y curl
> while sleep 1; do curl -s search:9200 | grep name | grep -v cluster; done
```
  "name" : "Poison",
  "name" : "Apollo",
  "name" : "Apollo",
  "name" : "Apollo",
  "name" : "Apollo",
  "name" : "Apollo",
  "name" : "Poison",
  "name" : "Poison",
  ...

```


